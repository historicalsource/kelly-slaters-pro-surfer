#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sndfile.h"
#include "encvag.h"

#include "../../ps2/gas.h"
#include "../../ps2/gas/GasSystem.h"

#include "PS2SoundTool.h"

#define STRING_LENGTH 256
#define MAX_LINES 600

// make sure to keep these in sync with the module's allocation of SPU ram
#ifdef ADPCM_TOOL

#undef MAX_CD_STEREO_STREAMS
#define MAX_CD_STEREO_STREAMS 2

#undef MAX_CD_MONO_STREAMS
#define MAX_CD_MONO_STREAMS 8

#endif // ADPCM_TOOL

#define BLK_SIZE 2048
#define SPU_BLK_SIZE 16
#define REAL_SPU_BLK_SIZE 56

#define REAL_BLK_SIZE ( ( BLK_SIZE / SPU_BLK_SIZE ) * REAL_SPU_BLK_SIZE )

#define AUDIO_IN_EXT ".wav"
#define AUDIO_OUT_EXT ".vbc"

#define g_spu_buffer_num  ((MAX_CD_STEREO_STREAMS * 2) + MAX_CD_MONO_STREAMS)
#define g_spu_heap_start  (SPU_MEMORY_TOP + (SPU_BUFFER_SIZE * g_spu_buffer_num))
#define g_spu_heap_end    (SPU_MEMORY_MAX)

static int g_spu_heap_curr = (g_spu_heap_start);

static unsigned int g_cd_offset = 0;

static GasSource cachedsounds[1000];
static int currentCachedCount = 0;
static int cached[2000];

#define STRING_LENGTH 256
#define MAX_LINES 600

static char lines[MAX_LINES][STRING_LENGTH];

// in soundfileparser.c
extern int process_line(char *line, GasSource *entry);

static FILE* cd_file = NULL;

// cleans up the full_filename field in a GasSource struct
// removes extension, converts to uppercase and converts / to \\
// should this go into the gas module?

int clean_filename(GasSource *entry)
{
  int pos, len;
  char *str;

  len = strlen( entry->filename );

  pos = len;
  // Strip an extension, if any
  while( pos > len - 6 && pos >= 0 )
  {
    if( entry->filename[pos] == '.' ){
      entry->filename[pos] = '\0';
      break;
    }
    pos--;
  }


  // convert to upper case and convert slashes
  str = entry->filename;
  while( *str != '\0' )
  {
    *str = toupper(*str);
    if( *str == '/' ) *str = '\\';
    str++;
  }
  return 1;
}

// Reads in a SND file
// this strips comments, leading whitespace and leading slashes
// again, should this go into the gas module?
// should this strip the leading slashes?
// compelling questions of our time
int read_list(FILE *list, int *num_lines)
{
  int line_count;
  char line[STRING_LENGTH * 2];

  // read in lines
  line_count = 0;
  while( fgets( line, STRING_LENGTH * 2, list ) )
  {
    int len = strlen( line );
    char *line_start, *comment, *newline;
    
    if( len >= STRING_LENGTH )
    {
      printf( "Line too long ( >=%d )\n", STRING_LENGTH );
      return 0;
    }

    if( line_count == MAX_LINES )
    {
      printf( "Too many lines ( MAX_LINES = %d )\n", MAX_LINES );
      return 0;
    }

    newline = line;
    while( *newline != '\0' ){
      if( *newline == '\n' || *newline == 0x0a ){
        *newline = '\0';
        break;
      }
      newline++;
    }

    line_start = line + strspn( line, " \t/\\" ); // strip leading crap
    comment = strchr( line_start, ';' );
    if( comment ) *comment = '\0';

    len = strlen( line_start );

    if( len ){
      strcpy( lines[ line_count ], line_start );
      line_count++;
    }
  }

  *num_lines = line_count;

  return 1;
}

// Outputs num_entries entries, to file 'list'
// pass stdout if you want to redirect to the screen
// FIXME: if not given, voll, volr, rvoll, rvolr are all set to 100
// this messes up stereo files
int output_list(FILE *list, int num_entries, GasSource *entries)
{
  int i;

  fprintf( list, ";WARNING WARNING!!\n;DO NOT EDIT THIS FILE!\n;THIS FILE IS GENERATED BY ADPCMTOOL\n" );
  
  for( i = 0; i < num_entries; i++ )
  {
    GasSource *entry = &entries[i];

    if( entry->size == 0 ) continue;
    if( entry->flag.src_type == SRC_TYPE_CD ) continue;

    fprintf( list, "%s size %d offset %d freq %d voll %d volr %d %s %s %s %s\n",
                    get_basename( entry->filename ),
                    entry->size,
                    entry->offset,
                    entry->freq,
                    entry->voll,
                    entry->volr,
                    ( entry->flag.src_type == SRC_TYPE_SPU ? "spu" : "cd" ),
                    ( entry->flag.loop ? "loop" : "" ),
                    ( entry->flag.stereo ? "stereo" : "mono" ),
                    ( entry->sound_type==SOUND_TYPE_VOICE) ? "voice": ( entry->sound_type==SOUND_TYPE_MUSIC) ? "music": ( entry->sound_type==SOUND_TYPE_AMBIENT) ? "ambient":"sfx");
  }

  for( i = 0; i < num_entries; i++ )
  {
    GasSource *entry = &entries[i];

    if( entry->size == 0 ) continue;
    if( entry->flag.src_type == SRC_TYPE_SPU ) continue;

    fprintf( list, "%s  size %d offset %d freq %d voll %d volr %d %s %s %s %s\n",
                    get_basename( entry->filename ),
                    entry->size,
                    entry->offset,
                    entry->freq,
                    entry->voll,
                    entry->volr,
                    ( entry->flag.src_type == SRC_TYPE_SPU ? "spu" : "cd" ),
                    ( entry->flag.loop ? "loop" : "" ),
                    ( entry->flag.stereo ? "stereo" : "mono" ),
                    ( entry->sound_type==SOUND_TYPE_VOICE) ? "voice": ( entry->sound_type==SOUND_TYPE_MUSIC) ? "music": ( entry->sound_type==SOUND_TYPE_AMBIENT) ? "ambient":"sfx");
  }
  return 0;
}


// Converts the entry->full_filename WAV file to a TVB
// man, this code sucks
// FIXME: comment this so it is a bit clearer or clean the code
int convert_file(GasSource *entry, int dry_run)
{
  SNDFILE *aiff;
  SF_INFO aiff_info;
  char src_file[256];
  short *in_buffer;
  char *buffer_ptr, *vag_ptr;
  int vag_buffer_bytes;

  clean_filename( entry );
  sprintf( src_file, "%s%s%s", opt_input_wav_dir, entry->filename, AUDIO_IN_EXT );
  
  aiff = sf_open_read( src_file, &aiff_info );

  if( aiff == NULL )
  {
    printf( "Could not open aiff file: %s\n", src_file );
    return 0;
  }

  if( aiff_info.pcmbitwidth != 16 )
  {
    printf( "Must be a 16-bit sample\n" );
    sf_close( aiff );
    return 0;
  }
  
  entry->flag.stereo = ( aiff_info.channels == 2 ? 1 : 0 );

  if( aiff_info.channels == 1 )
  {

    int file_samples = aiff_info.samples;
    int file_bytes;
    int buffer_bytes;
    int buffer_samples;

    if( entry->flag.loop )
    {
      const int div = REAL_BLK_SIZE / 2;
      file_samples = ( file_samples / div ) * div;
    }
    
    file_bytes = file_samples * 2;
    
    buffer_bytes = ( ( file_bytes + REAL_BLK_SIZE - 1 ) / REAL_BLK_SIZE ) * REAL_BLK_SIZE;
    buffer_samples = buffer_bytes / 2;
    
    in_buffer = malloc( buffer_bytes );
    memset( in_buffer, 0, buffer_bytes );

    sf_read_short( aiff, in_buffer, file_samples );

    vag_buffer_bytes = ( buffer_bytes / REAL_SPU_BLK_SIZE ) * SPU_BLK_SIZE ;
    entry->vag_buffer = malloc( vag_buffer_bytes );
  }
  else if( aiff_info.channels == 2 )
  {
    short *buffer_c;
    short *a_buffer, *b_buffer;
    int i;
    int file_samples = aiff_info.samples;
    int file_bytes;
    int buffer_bytes;
    if( entry->flag.loop )
    {
      const int div = REAL_BLK_SIZE / 2;
      file_samples = ( file_samples / div ) * div;
    }
    file_bytes = file_samples * 2;

    buffer_bytes = ( ( file_bytes + REAL_BLK_SIZE - 1 ) / REAL_BLK_SIZE ) * REAL_BLK_SIZE;

    in_buffer = malloc( buffer_bytes * 2 );

    buffer_c = malloc( buffer_bytes * 2 );
    memset( buffer_c, 0, buffer_bytes * 2 );

    sf_read_short( aiff, buffer_c, file_samples * 2 );
    
    a_buffer = in_buffer;
    b_buffer = buffer_c;
    while( a_buffer != ( in_buffer + buffer_bytes) ) // buffer_bytes = buffer_samples / 2
    {
      for( i = 0; i < REAL_BLK_SIZE / 2; i++ )
      {
        a_buffer[i] = b_buffer[i * 2];
        a_buffer[i + REAL_BLK_SIZE / 2] = b_buffer[i * 2 + 1];
      }
      a_buffer += REAL_BLK_SIZE;
      b_buffer += REAL_BLK_SIZE;
    }

    free( buffer_c );

    vag_buffer_bytes = ( buffer_bytes * 2 / REAL_SPU_BLK_SIZE ) * SPU_BLK_SIZE;
    entry->vag_buffer = malloc( vag_buffer_bytes );
  }

  entry->size = vag_buffer_bytes;
  entry->freq = aiff_info.samplerate;

  buffer_ptr = (char *)in_buffer;
  vag_ptr = (char *)entry->vag_buffer;

  EncVagInit( 1 );
  do
  {
    EncVag( (short *)buffer_ptr, (short *)vag_ptr, 3 );
    buffer_ptr += REAL_SPU_BLK_SIZE;
    vag_ptr += SPU_BLK_SIZE;
  }while( vag_ptr != ( entry->vag_buffer + vag_buffer_bytes ) );
  
  sf_close( aiff );
  free( in_buffer );

  return 1;
}





#define TYPE(X) entries[(X)].flag.src_type
#define SIZE(X) entries[(X)].size


// the compare_tbl determines what action to take when comparing two entries
// NO_ACTION: don't do anything
// COMPARE: compare the size values, if seeker is less than min then min = seeker
// SWAP: min = seeker
#define NO_ACTION 0
#define COMPARE 1
#define SWAP 2
static int compare_tbl[3][3] = {
/*             SPU   |   CD     |   NONE     */
/*SPU */   { COMPARE, NO_ACTION, NO_ACTION },
/*CD  */   { SWAP,    COMPARE,   SWAP },
/*NONE*/   { SWAP,    NO_ACTION, COMPARE }
};

// Sort entries based on type and size
void sort_entries(GasSource *entries, int num_entries)
{
  int head, seeker, min;

  head = 0;
  seeker = 1;
  min = 0;


  // crappy bubble sort
  for( head = 0; head < num_entries - 1; head++ )
  {
    min = head;
    for( seeker = head + 1; seeker < num_entries; seeker++ )
    {
      switch( compare_tbl[TYPE(min)][TYPE(seeker)] )
      {
      case NO_ACTION:
        break;
      case COMPARE:
        if( SIZE(seeker) < SIZE(min) ) min = seeker;
        break;
      case SWAP:
        min = seeker;
        break;
      default:
        printf( "UHHHHH!!!!\n\n\n\n" );
        break;
      }
    }
    if( min != head )
    {
      GasSource temp_src;
      int temp_int = cached[head];
      cached[head] = cached[min];
      cached[min] = temp_int;

      memcpy( &temp_src, &entries[head], sizeof( GasSource ) );
      memcpy( &entries[head], &entries[min], sizeof( GasSource ) );
      memcpy( &entries[min], &temp_src, sizeof( GasSource ) );
    }
  }
}

void set_loop_entries (GasSource *entries, int num_entries ) 
{
  int i;
  for (i=0; i < num_entries; i++) 
  {
    if (entries[i].flag.src_type == SRC_TYPE_SPU && entries[i].vag_buffer) 
    {
      if (entries[i].flag.loop) 
      {

        _AdpcmSetMarkLOOP(entries[i].vag_buffer, entries[i].size);
      }
      else 
      {
        _AdpcmSetMarkSTOP(entries[i].vag_buffer, entries[i].size);
      }
    }

  }
}


// Determine whether an entry should be stored in SPU ram or not
void memify_entries( GasSource *entries, int num_entries )
{
  int spu_mem_free = g_spu_heap_end - g_spu_heap_start;
  int i,j;
  int found = 0;
  int spu_offset = 0;
  
  for( i = 0; i < num_entries; i++ )
  {
    if( entries[i].flag.stereo == 1 )
    {
      if( TYPE(i) == SRC_TYPE_SPU )
      {
        printf( "Warning (%s), stereo files must be stored on CD\n", entries[i].filename );
      }
      TYPE(i) = SRC_TYPE_CD;
    }
      if( (int)SIZE(i) < spu_mem_free && TYPE(i) != SRC_TYPE_CD )
    {
      TYPE(i) = SRC_TYPE_SPU;
      spu_mem_free -= SIZE(i);
    }
    else if( TYPE(i) == SRC_TYPE_SPU )
    {
      printf( "WARNING: Out of SPU memory for %s (%d bytes)\n", entries[i].filename, SIZE(i) );
      TYPE(i) = SRC_TYPE_CD;
    }

    if( TYPE(i) == SRC_TYPE_SPU )
    {
      entries[i].offset = spu_offset;
      spu_offset += SIZE(i);
    }
    else
    {
      if (cached[i] >= 0) 
      {
          entries[i] = cachedsounds[cached[i]];
      } 
      else 
      {
        //printf("Not found while memifying\n");
        entries[i].offset = g_cd_offset;
        g_cd_offset += SIZE(i);
        found = 0;
        j =0;
        while ((j < currentCachedCount) && (!found))
        {
          if (strcmp(cachedsounds[j].filename, entries[i].filename)==0)
          {
            found = 1;
            cachedsounds[j].offset = entries[i].offset;
          }
          j++;
        }

      }

        
    }
  }
  printf( "SPU Mem Used: %d\nSPU Mem Free: %d\n",
          (g_spu_heap_end - g_spu_heap_start) - spu_mem_free,
          spu_mem_free );
}

#undef TYPE

void free_entries(GasSource *entries, int num_entries)
{
  int i;

  for( i = 0; i < num_entries; i++ )
    if( entries[i].vag_buffer ) free( entries[i].vag_buffer );

  free( entries );
}


void output_collections(GasSource *entries, int num_entries, FILE *spu, FILE *cd)
{
  int i;

  for( i = 0; i < num_entries; i++ )
  {
    if( entries[i].flag.src_type == SRC_TYPE_SPU )
      fwrite( entries[i].vag_buffer, entries[i].size, 1, spu );
    else
    {
      if (cached[i]<0)
        fwrite( entries[i].vag_buffer, entries[i].size, 1, cd );
    }
  }
}

int pre_export_ps2( void )
{
  if( !opt_dryrun )
  {
    char cd_collection[256];
    if ((cd_collection[strlen(cd_collection) -1] != '\\') &&
        (cd_collection[strlen(cd_collection) -1] != '\\'))
    {
      sprintf( cd_collection, "%s\\stream.vbc", opt_ps2_out_dir );
    }
    else
    {
      sprintf( cd_collection, "%sstream.vbc", opt_ps2_out_dir );
    }
    cd_file = fopen( cd_collection, "wb" );

    if( !cd_file )
    {
      printf( "Could not open cd output file: %s\n", cd_collection ); 
      exit( 1 );
    } 
  }

	return 0;
}

int post_export_ps2( void )
{
  if( !opt_dryrun )
    fclose( cd_file );

	return 0;
}

int start_level_ps2( const char* level )
{
		int num_lines, found;
    int i,j ;
    FILE *list, *list_out, *spu_file;
    char filename[256];
    char spu_collection[256];

    sprintf( filename, "%s\\%s.snd", opt_input_snd_dir, level );
    sprintf( spu_collection, "%s\\%s\\%s.vbc", opt_ps2_out_dir, opt_ps2_spu_dir, level );

    // Export the PS2 sounds here
    list = fopen( filename, "r" );
    
    if( list == NULL )
    {
      printf( "Error opening file %s\n", filename );
    }
    else
    {
      GasSource *entries;
      read_list( list, &num_lines );
      entries = malloc( sizeof( GasSource ) * num_lines );
      for( i = 0; i < num_lines; i++ )
      {
        process_line( lines[i], &entries[i] );
        if (entries[i].flag.src_type == SRC_TYPE_CD)
        {
          found = 0;
          j=0;
          while ((j < currentCachedCount) && (!found))
          {
            if (strcmp(cachedsounds[j].filename, entries[i].filename)==0)
            {
              found = 1;
              cached[i] = j;
            }
            j++;
          }
          if (!found)   
          {
            //printf("Not found\n");
            cached[i] = -1;
            convert_file( &entries[i], opt_dryrun );
            if (currentCachedCount < 1000)
            {
              //printf("Adding %s to cache list\n", entries[i].filename);
              cachedsounds[currentCachedCount] = entries[i];
              // Not really the data.. just info
              // we don't want to free twice
              cachedsounds[currentCachedCount].vag_buffer = 0;
              currentCachedCount++;
            } 
          }
        } 
        else 
        {
          cached[i]=-1;
          convert_file( &entries[i], opt_dryrun );
        }
      }
      sort_entries( entries, num_lines );
      memify_entries( entries, num_lines );
      set_loop_entries( entries, num_lines );
      sprintf( filename, "%s\\%s\\%s.snd", opt_ps2_out_dir, opt_level_dir, level );
      if( opt_dryrun )
        list_out = stdout;
      else
      {
        list_out = fopen( filename, "w" );
        spu_file = fopen( spu_collection, "wb" );
      }
      if( list_out == NULL )
      {
        printf( "Error opening file %s\n", filename );
      }
      else if( spu_file == NULL )
      {
        printf( "Error opening file %s\n", spu_collection );
      }
      else
      {
        output_list( list_out, num_lines, entries );
        fprintf( list_out, "COLLECTION ps2sound\\%s\\%s.vbc\n", opt_ps2_spu_dir, level );
        if( !opt_dryrun )
        {
          output_collections( entries, num_lines, spu_file, cd_file );
          fclose( spu_file );
          fclose( list_out );
        }
      }
      free_entries( entries, num_lines );

      fclose( list );
    }

		return 0;
}

int end_level_ps2( const char* filename )
{
	return 0;
}

int export_file_ps2( snd_info_t* info )
{
	return 0;
}
