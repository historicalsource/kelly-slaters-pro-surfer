//portDVDCache.cpp --  handles asynchronous load of game files to utility drive!

#include "global.h"
#include "string.h"
//#include "utils.h"
#include <process.h>

#include "xb_portDVDCache.h"

#define CACHE_LOG_FILE          "z:\\CacheLog.bin"
#define CACHE_VERSION_FILE      "t:\\CacheVersion.bin"
#define CACHE_LOG_FREQUENCY     16    // how often to write out the log.  It'll write once per this many files (lower = more often)
#define PAUSE_DURATION          2000

// define a timestamp based on compile time that's unique for 
// every second of the day (so it ranges from 0 to 86399)
#define TIMEDIGIT(x)            (__TIME__[x] - '0')
#define TIMESTAMP               TIMEDIGIT(7) + TIMEDIGIT(6) * 10 + TIMEDIGIT(4) * 60 + TIMEDIGIT(3) * 600 + TIMEDIGIT(1) * 3600 + TIMEDIGIT(0) * 36000

int     CACHE_FILE_VERSION      = TIMESTAMP; 

extern SubDir gFileCacheSubdirTable[];
extern FileTableEntry gFileCacheTable[];

// Include the list of sub-directories in the disk image directory
// This file defines the FileCacheSubdirTable, used in xb_portDVDCache.cpp
// This file is automatically generated by MakeFileCacheTable.bat
#include "xb_FileCacheSubdirTable.h"

// Include the list of files in the disk image directory, indexed to their specific sub-directory
// This file defines the FileCacheTable, used in xb_portDVDCache.cpp
// This file is automatically generated by MakeFileCacheTable.bat
#include "xb_FileCacheTable.h"

DVDCache gDVDCache;

DVDCache::DVDCache()
{
	FileCacheTable = ::gFileCacheTable;
	FileCacheSubdirTable = ::gFileCacheSubdirTable;
	numCacheSubdirs = sizeof(gFileCacheSubdirTable) / sizeof(SubDir);
	numCacheableFiles = sizeof(gFileCacheTable) / sizeof(FileTableEntry);
	
	cacheActive      = false;
	DVDCacheHandle   = NULL;
	CacheWorking     = false;
	TotalPauseTime   = 0;
	CurrentFileID    = 0;
	FilesCached      = 0;
	CurrentFileSize  = 0;
	SrcSectorSize    = 0;
	DestSectorSize   = 0;
}

void DVDCache::PauseDVDCache()
{
	if(!os_developer_options::inst()->is_flagged( os_developer_options::FLAG_CACHE_TO_DISK))
		return;
	//  debug_print("PauseDVDCache() called\n");
	TotalPauseTime = PAUSE_DURATION;
}

void DVDCache::UpdateCacheFile()
{
	//Write out version file
	HANDLE hFile = CreateFile( CACHE_VERSION_FILE, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );
	
	if( hFile == INVALID_HANDLE_VALUE )
	{
		debug_print("Couldn't open Cache version file: %s\n", CACHE_VERSION_FILE); 
		return;
	}
	
	DWORD BytesWritten = 0;
	bool result = WriteFile( hFile, &CACHE_FILE_VERSION, sizeof(CACHE_FILE_VERSION), &BytesWritten, NULL );
	
	CloseHandle( hFile );
	hFile = NULL;
	
	if( !(BytesWritten == sizeof(CACHE_FILE_VERSION) && result) )
	{
		DWORD error = GetLastError();
		debug_print("Drive Full?!\n");
		assertmsg(false,"cache drive full\n");
	}
	
	//Write out cache log
	hFile = CreateFile( CACHE_LOG_FILE, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );
	
	if( hFile == INVALID_HANDLE_VALUE )
	{
		debug_print("Couldn't open %s\n", CACHE_LOG_FILE); 
		return;
	}
	
	bool *cacheresults = (bool*)malloc( numCacheableFiles );
	int i;
	for( i = 0; i < numCacheableFiles; ++i )
		cacheresults[ i ] = FileCacheTable[ i ].cached==fcsCached;
	
	
	BytesWritten = 0;
	result = WriteFile( hFile, cacheresults, numCacheableFiles, &BytesWritten, NULL );
	
	free((void*)cacheresults);
	CloseHandle( hFile );
	hFile = NULL;
	
	if( !(BytesWritten == numCacheableFiles && result) )
	{
		DWORD error = GetLastError();
		debug_print("Drive Full?!\n");
		assertmsg(false,"cache drive full\n");
	}
}

void DVDCache::InitDVDCache()
{
	HANDLE hFile;
	
	if(!os_developer_options::inst()->is_flagged( os_developer_options::FLAG_CACHE_TO_DISK))
		return;
	
	//Load in version number
	hFile = CreateFile( CACHE_VERSION_FILE, GENERIC_READ, 0, NULL, OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );
	
	bool NukeItFromOrbitItsTheOnlyWayToBeSure = false;
	if( hFile == INVALID_HANDLE_VALUE )
	{
		debug_print("%s doesn't exist yet\n", CACHE_VERSION_FILE);
		NukeItFromOrbitItsTheOnlyWayToBeSure = true;
	}
	else
	{
		DWORD Version, BytesRead = 0;
		bool result = ReadFile( hFile, &Version, sizeof(CACHE_FILE_VERSION), &BytesRead, NULL );
		CloseHandle( hFile );
		
		if( !(BytesRead == sizeof(CACHE_FILE_VERSION) && result) )
		{
			DWORD error = GetLastError();
			if(error == ERROR_SUCCESS) // if the read was successful then the file is just empty
				NukeItFromOrbitItsTheOnlyWayToBeSure = true;
			else
				assertmsg(false,"Error reading disk cache version file");
		}
		else if(Version != CACHE_FILE_VERSION)
		{
			NukeItFromOrbitItsTheOnlyWayToBeSure = true;
		}
	}
	
	XMountUtilityDrive( NukeItFromOrbitItsTheOnlyWayToBeSure );
	
	SrcSectorSize  = XGetDiskSectorSize( "D:\\" ) - 1;
	DestSectorSize = XGetDiskSectorSize( "Z:\\" ) - 1;
	
	int i, j;
	for( i = 1; i < numCacheSubdirs; ++i )
	{
		j = 0;
		while( FileCacheSubdirTable[i].subdir[j] )
		{
			if( FileCacheSubdirTable[i].subdir[j] == '\\')
			{
				FileCacheSubdirTable[i].subdir[j] = 0;
				char dir[ 64 ] = "z:\\";
				strcat(dir, FileCacheSubdirTable[i].subdir);
				CreateDirectory( dir, NULL);
				FileCacheSubdirTable[i].subdir[j] = '\\';
			}
			++j;
		}
	}
#if defined(_BIN_) || SEAN
	if( NukeItFromOrbitItsTheOnlyWayToBeSure )
#endif
		return;
	
	//Load in Cache Log
	hFile = CreateFile( CACHE_LOG_FILE, GENERIC_READ, 0, NULL, OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
		NULL );
	
	if( hFile == INVALID_HANDLE_VALUE )
	{
		debug_print("%s doesn't exist yet\n", CACHE_LOG_FILE); 
		return;
	}
	
	bool *cacheresults = (bool*)malloc( numCacheableFiles );
	
	DWORD BytesRead = 0;
	bool result = ReadFile( hFile, cacheresults, numCacheableFiles, &BytesRead, NULL );
	
	if( BytesRead == numCacheableFiles && result )
	{
		int i;
		for( i = 0; i < numCacheableFiles; ++i )
			FileCacheTable[ i ].cached = cacheresults[ i ] ? fcsCached : fcsNotCached;
	}
	else
	{
		DWORD error = GetLastError();
#if !SHOWFATALERRORS
		assertmsg(false,"");
#endif
	}
	free((void*)cacheresults);
	
	CloseHandle( hFile );
	hFile = NULL;
}

bool DVDCache::VerifyCacheFile(long FileID)
{
	if (FileCacheTable[ FileID ].cached == fcsCached)
		return true;
	char CacheName[ 96 ] = "z:\\",
		OrigName[ 96 ];
	WIN32_FILE_ATTRIBUTE_DATA OrigAttrib, CacheAttrib;
	
	strcat(CacheName, FileCacheSubdirTable[ FileCacheTable[ FileID ].subdirID ].subdir);
	strcat(CacheName, FileCacheTable[ FileID ].fname);
	
	strcpy(OrigName, CacheName);
	OrigName[ 0 ] = 'd';
	
	bool CacheFound = GetFileAttributesEx( CacheName, GetFileExInfoStandard, (void *)&CacheAttrib );
	if (!CacheFound)
		return false;
	
	bool OrigFound  = GetFileAttributesEx( OrigName,  GetFileExInfoStandard, (void *)&OrigAttrib );
	if (!OrigFound)
		return false;
	
	if( CacheAttrib.ftLastWriteTime.dwHighDateTime == OrigAttrib.ftLastWriteTime.dwHighDateTime &&
		CacheAttrib.ftLastWriteTime.dwLowDateTime == OrigAttrib.ftLastWriteTime.dwLowDateTime )
	{
		if( OrigAttrib.nFileSizeHigh == CacheAttrib.nFileSizeHigh &&
			OrigAttrib.nFileSizeLow == CacheAttrib.nFileSizeLow )
		{
			FileCacheTable[ FileID ].cached = fcsCached;
			return true;
		}
	}
	return false;
}

bool DVDCache::IsFileCached(const char *filename)
{
	if (*filename=='\\')
		++filename; // skip leading backslash
	
	char fname[96];
	int i;
	
	for( i = 0; i < numCacheableFiles; ++i )
	{
		strcpy( fname, FileCacheSubdirTable[ FileCacheTable[i].subdirID ].subdir );
		strcat( fname, FileCacheTable[ i ].fname );
		
		if( !strcmp( fname, filename ) )
		{
			break;
		}
	}
	
	if( i == numCacheableFiles )
	{
	/*
	If you hit this, it means that your filename is not in the table in
	"portDVDCacheTable.cpp".  Perhaps the list needs to be re-generated?
	To do so, run MakeFileCacheTable.bat in c:\ks\data.  (note: this 
	batch file requires 4DOS or 4NT).  Otherwise, add te file, following 
	the format of the others, in "portDVDCache.h".  The order of the 
	files in the array is order of load priority: 
	(0) Highest, (numCacheableFiles-1) Lowest.
		*/
		debug_print("************ file \"%s\" not in cache list\n", filename);
		return false;
	}
	
	while (FileCacheTable[i].cached == fcsCaching)
	{
		// wait for caching thread to finish
	}
	if (FileCacheTable[i].cached == fcsCached)
	{
		return true;
	}
	return VerifyCacheFile(i);
}

void DVDCache::CacheLoadedFile(char *filename, void *data, long size)
{
	if(!os_developer_options::inst()->is_flagged( os_developer_options::FLAG_CACHE_TO_DISK))
		return;
	
	if (*filename=='\\')
		++filename; // skip leading backslash
	
	int i, j;
	char name[ 96 ];
	
	for( i = 0; i < numCacheableFiles; ++i )
	{
		strcpy(name, FileCacheSubdirTable[ FileCacheTable[ i ].subdirID ].subdir);
		strcat(name, FileCacheTable[ i ].fname);
		
		if( !strcmp( name, filename ) )
		{
			break;
		}
	}
	
	if( i == numCacheableFiles )
	{
		debug_print("%s not in cache list, unable to cache from loaded file\n", filename);
		return;
	}
	
	if( FileCacheTable[i].cached!=fcsNotCached )
	{
		return;
	}
	FileCacheTable[i].cached=fcsCaching;
	
	strcpy(name, "z:\\");
	strcat(name, FileCacheSubdirTable[ FileCacheTable[ i ].subdirID ].subdir);
	strcat(name, FileCacheTable[ i ].fname);
	
	
	HANDLE hFile = CreateFile( name, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
		NULL );
	
	if( hFile == INVALID_HANDLE_VALUE )
	{
		debug_print("Couldn't open %s, may be in use...\n", name); 
		return;
	}
	
	DWORD BytesWritten = 0;
	bool result = WriteFile( hFile, data, size, &BytesWritten, NULL );
	
	name[ 0 ] = 'd';
	WIN32_FILE_ATTRIBUTE_DATA OrigAttrib;
	
	GetFileAttributesEx( name,  GetFileExInfoStandard, (void *)&OrigAttrib );
	SetFileTime( hFile, &OrigAttrib.ftCreationTime, &OrigAttrib.ftLastAccessTime, &OrigAttrib.ftLastWriteTime );
	
	CloseHandle( hFile );
	hFile = NULL;
	
	if( BytesWritten == size && result )
	{
		FileCacheTable[ i ].cached = fcsCached;
		//    FileCacheTable[ i ].fsize  = size;
	}
	else
	{
		FileCacheTable[ i ].cached = fcsNotCached;
		DWORD error = GetLastError();
		debug_print("Drive Full?!\n");
		assertmsg(false,"cache drive full\n");
	}
}

void DVDCache::CacheFile(const char *filename)
{
	int i;
	bool failed = 0;
	
	for( i = 0; i < numCacheableFiles; ++i )
	{		
		if( !strcmp( FileCacheTable[ i ].fname, filename ) )
		{
			break;
		}
	}
	
	if( i == numCacheableFiles )
	{
		debug_print("%s not in cache list, unable to cache from loaded file\n", filename);
		return;
	}
	
	if( FileCacheTable[i].cached!=fcsNotCached )
	{
		return;
	}
	CacheFile(i);
}

void DVDCache::CacheFile(const int file_to_cache)
{
	bool failed = false;
	
	if (FileCacheTable[file_to_cache].cached != fcsNotCached) 
		return;
	if (VerifyCacheFile(file_to_cache))
		return;
	FileCacheTable[file_to_cache].cached = fcsCaching;
	
	char name[ 96 ] = "d:\\";
	strcat(name, FileCacheSubdirTable[ FileCacheTable[ file_to_cache ].subdirID ].subdir);
	strcat(name, FileCacheTable[ file_to_cache ].fname);
	
	HANDLE hSrcFile = CreateFile( name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
		FILE_FLAG_NO_BUFFERING | FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, 
		NULL );
	
	
	WIN32_FILE_ATTRIBUTE_DATA OrigAttrib;
	GetFileAttributesEx( name,  GetFileExInfoStandard, (void *)&OrigAttrib );
	
	CurrentFileSize = OrigAttrib.nFileSizeLow;
	
	if( CurrentFileSize == 0 )
	{
		debug_print("%s Filesize == 0\n", FileCacheTable[ file_to_cache ].fname);
		return;
	}
	
	if( hSrcFile == INVALID_HANDLE_VALUE )
	{
		debug_print("Couldn't open %s, may be in use or file may no longer exist...\n", name); 
		FileCacheTable[file_to_cache].cached = fcsCantCache;
		// This is commented out to make for friendly failure when trying to cache files that don't exist DAJ 7-12-02
		//assertmsg(false,"Couldn't read off dvd to cache file\n");
		return;
	}
	
	name[ 0 ] = 'z';
	
	HANDLE hDestFile = CreateFile( name, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING | FILE_ATTRIBUTE_NORMAL, 
		NULL );
	
	if( hDestFile == INVALID_HANDLE_VALUE )
	{
		CloseHandle( hSrcFile );
		hSrcFile = NULL;
		FileCacheTable[file_to_cache].cached = fcsNotCached;
		DWORD error = GetLastError();
		if( error == ERROR_SHARING_VIOLATION )
			debug_print("other thread already caching %s\n", name);
		else
			assertmsg(false,"Couldn't write to cache file\n");
		return;
	}
	
	SetFilePointer( hDestFile, CurrentFileSize, NULL, FILE_BEGIN );
	SetEndOfFile( hDestFile );
	SetFilePointer( hDestFile, 0, NULL, FILE_BEGIN );
	
	void *Buffer = malloc((CurrentFileSize+SrcSectorSize)&~SrcSectorSize);

	assert(Buffer);
	
	DWORD Read, Written;
	if( !ReadFile( hSrcFile, Buffer, ((CurrentFileSize+SrcSectorSize)&~SrcSectorSize), &Read, NULL ) )
	{
		DWORD error = GetLastError();
		//assertmsg( 0, "IO ERROR\n" );
	}
	
	if( !WriteFile( hDestFile, Buffer, ((CurrentFileSize+DestSectorSize)&~DestSectorSize), &Written, NULL ) )
	{
		DWORD error = GetLastError();
		//assertmsg( 0, "IO ERROR\n" );
		if(error == ERROR_DISK_FULL)
		{
			debug_print("HARD DRIVE ( Z DRIVE ) IS FULL )\n");
			assertmsg(false,"cache drive full");
		}
		else
		{
			assertmsg(0, "ASK DAVID J. TO LOOK AT THIS, AND DON'T TURN IT OFF\n");
		}
		failed = true;
	}
	
	free((void*)Buffer);
	
	CloseHandle( hSrcFile );
	hSrcFile = NULL;
	
	SetFileTime( hDestFile, &OrigAttrib.ftCreationTime, &OrigAttrib.ftLastAccessTime, &OrigAttrib.ftLastWriteTime );
	
	CloseHandle( hDestFile );
	hDestFile = NULL;
	
	hDestFile = CreateFile( name, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 
		FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, NULL );
	SetFilePointer( hDestFile, CurrentFileSize, NULL, FILE_BEGIN );
	SetEndOfFile( hDestFile );
	CloseHandle( hDestFile );
	hDestFile = NULL;
	
	debug_print("%s CACHED!\n", FileCacheTable[file_to_cache].fname);
	
	if( !failed )
	{
		FileCacheTable[ file_to_cache ].cached = fcsCached;    
		//    FileCacheTable[ file_to_cache ].fsize  = CurrentFileSize;
	}
	else
	{
		FileCacheTable[file_to_cache].cached = fcsNotCached;
	}
}

void DVDCache::StartCaching()
{
	// If we aren't running from stashes or if caching is turned off or if 
	// we're already finished, return without doing anything.
	if(!os_developer_options::inst()->is_flagged(os_developer_options::FLAG_CACHE_TO_DISK) ||
	   !os_developer_options::inst()->is_flagged(os_developer_options::FLAG_STASH_ONLY) ||
	    finished())
		return;
	
	if (!CacheWorking)
	{
		cacheActive = true;
		CacheWorking = true;
		DVDCacheHandle = (HANDLE)_beginthread(HandleDVDCache, 8*1024, NULL);
		if (DVDCacheHandle == (HANDLE)-1) DVDCacheHandle = NULL;
	}
}

void DVDCache::StopCaching()
{
	if(!os_developer_options::inst()->is_flagged( os_developer_options::FLAG_CACHE_TO_DISK))
		return;
	
	UpdateCacheFile();
	cacheActive = false;
	
	
	if (!CacheWorking || !DVDCacheHandle) 
		return;
	//  while (CacheWorking) Sleep(1);
	
	assertmsg(DVDCacheHandle != NULL, "Not initialized within HandleDVDCache?");
	
	if (DVDCacheHandle != NULL)
	{
		WaitForSingleObject(DVDCacheHandle, INFINITE);
		DVDCacheHandle = NULL;
	}
}

void __cdecl DVDCache::HandleDVDCache(void *nothing)
{
	gDVDCache.HandleDVDCacheHelper();
}


void DVDCache::HandleDVDCacheHelper()
{
	bool done = false; // set to true when all the files have been cached.
	
	// DVDCacheHandle = GetCurrentThread();
	
	//BOOL tpres = SetThreadPriority( GetCurrentThread(), -7 );
	//BOOL tpres = SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );
	//BOOL tpres = SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_LOWEST );
	//BOOL tpres = SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL );
	BOOL tpres = SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL ); // it won't run at any priority below this unless the other threads are blocked by pending file io ops
	assertmsg(tpres,"");
	tpres = SetThreadPriorityBoost( GetCurrentThread(), TRUE ); // disable priority boosting
	assertmsg(tpres,"");
	
	while( !done )
	{  
		while( TotalPauseTime )
		{
			debug_print("DVD Cache Paused!\n");
			int temp = TotalPauseTime;
			TotalPauseTime = 0;
			
			// Sleep(temp);
			while (temp > 100)
			{
				temp -= 100;
				Sleep(100);
				
				if( !cacheActive )
				{
					CacheWorking = false;
					return;
				}
			}
			
			if (temp > 0) Sleep( temp );
			
			debug_print("DVD Cache Awakens!\n");
		}
		
		if( !cacheActive )
		{
			CacheWorking = false;
			return;
		}
		
		if( CurrentFileID > numCacheableFiles )
		{
			done = true;
			for(int i = 0; i < numCacheableFiles; i++)
				if(FileCacheTable[i].cached != fcsCached)
					done = false;
				CurrentFileID = 0;
		}
		
		if( FileCacheTable[CurrentFileID].cached == fcsNotCached )
			CacheFile(CurrentFileID);
		
		CurrentFileID++;
		
		if(CurrentFileID % CACHE_LOG_FREQUENCY == 0)
			UpdateCacheFile();
	}
	
	CacheWorking = false;
	debug_print("All done!  All the files have been cached to disk.\n");
}

void DVDCache::TestCacheFile(const char *filename)
{
	int i;
	
	for( i = 0; i < numCacheableFiles; ++i )
	{
		if( !strcmp( FileCacheTable[i].fname, filename ) )
		{
			break;
		}
	}
	
	if( i == numCacheableFiles )
	{
		debug_print("%s not in cache list, unable to cache from loaded file\n", filename);
		assertmsg(0, "");
		return;
	}
	
	if( FileCacheTable[i].cached!=fcsCached )
	{
		debug_print("%s is not cached, YET!\n", filename);
		//    assertmsg(0, "");
		return;
	}
	
	char name[ FNAME_SIZE + 3 ] = "z:\\";
	strcat(name, FileCacheTable[ i ].fname);
	
	HANDLE hFile = CreateFile( name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
		FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, NULL );
	if( INVALID_HANDLE_VALUE == hFile )
	{
		debug_print("%s does not exists\n", name);
		assertmsg(0, "");
		return;
	}
	
	DWORD filesize = GetFileSize( hFile, NULL );
	void *data = malloc(filesize);
	
	DWORD sizeread = 0;
	
	if( !ReadFile( hFile, data, filesize, &sizeread, NULL ) )
	{
		DWORD error = GetLastError();
		debug_print("Unable to read %s\n", name);
	}
	
	if( sizeread != filesize )
	{
		free(data);
		assertmsg(0, "");
		return;
	}
	
	if(((char*)data)[0] == 'D' && ((char*)data)[1] == 'D' && ((char*)data)[2] == 'S')
	{
		//    debug_print("%s is cached and intact\n", filename);
	}
	else
	{
		free(data);
		assertmsg(0,"");
		return;
	}
	
	free(data);
}

bool DVDCache::finished()
{
	if(!os_developer_options::inst()->is_flagged( os_developer_options::FLAG_CACHE_TO_DISK))
		return true;
	
	return (FilesCached == numCacheableFiles);
}