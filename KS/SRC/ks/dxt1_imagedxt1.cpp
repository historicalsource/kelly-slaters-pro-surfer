
#include "global.h"
#include "dxt1_imagedxt1.h"
#include "dxt1_gen.h"

#ifdef TARGET_GC
const unsigned int ImageDXTC::Mask0565 = 0xf8fcf800;
#else
const unsigned int ImageDXTC::Mask0565 = 0x00f8fcf8; //0xf8fcf800;
#endif

// Lookups for which vectors in the DXTn block format map to which vectors in
// the codebook generated by DXTCGen.
const unsigned short ImageDXTC::ColorBits4[4] = { 0, 2, 3, 1 };
const unsigned short ImageDXTC::ColorBits3[3] = { 0, 2, 1 };

ImageDXTC::ImageDXTC()
{
	XSize = YSize = 0;
}

ImageDXTC::~ImageDXTC()
{
	ReleaseAll();
}

void ImageDXTC::ReleaseAll(void)
{
	XSize = YSize = 0;
}


// ----------------------------------------------------------------------------
// Used internally by CompressDXT1(), and CompressDXT3()
// Allocates the memory required for the block data
// ----------------------------------------------------------------------------
void ImageDXTC::SetSize(int x, int y)
{
	XSize = x;
	YSize = y;
}

// ----------------------------------------------------------------------------
// Build a DXT1 image from an Image32
// ----------------------------------------------------------------------------
void ImageDXTC::CompressDXT1(DXT1Color * imagePixels, const int imageWidth, const int imageHeight, unsigned short * destBlocks)
{
	int			x, y;
	unsigned short	*pDest;
	DXT1Color		*pSrc;
	CodeBook		cb, cb2, dcb, dcb2;
	DXT1Color		*pSrcPix, C, C2;
	int			xx, yy, AlphaCount;
	DXTCGen			GQuant;

	XSize = imageWidth;
	YSize = imageHeight;
	
	cb.SetCount(16);
	cb2.SetSize(16);

	pSrc = imagePixels;
	pDest = destBlocks;
	for(y=0; y<YSize; y+=4)
	{
		for(x=0; x<XSize; x+=4)
		{	
			// Compute a unique color list for the block
			cb2.SetCount(0);
			AlphaCount = 0;
			pSrcPix = pSrc;
			for(yy=0; yy<4; yy++)
			{
				for(xx=0; xx<4; xx++)
				{
					C.Col = pSrcPix[xx].Col & Mask0565;
					
					C.a = 0x00;
					cb[yy*4 + xx] = *(cbVector *)&C;
					cb2.AddVector( *(cbVector *)&C );
				}
				pSrcPix += XSize;
			}
			
			switch(cb2.GetNumCodes())
			{
			case 1:
				C.Col = *(int *)&cb2[0];
				Emit1ColorBlock(pDest, C);
				break;
				
			case 2:
				C = *((DXT1Color *)&cb2[0]);
				C2 = *((DXT1Color *)&cb2[1]);
				Emit2ColorBlock(pDest, C, C2, pSrc);
				break;
				
			default:
				int e3, e4;
				
				e3 = GQuant.Execute3(cb2, cb, dcb);
				e4 = GQuant.Execute4(cb2, cb, dcb2);
				
				if(e3 < e4)
					EmitMultiColorBlock3(pDest, dcb, pSrc);
				else
					EmitMultiColorBlock4(pDest, dcb2, pSrc);
				break;
			}
			
			pDest += 4;
			pSrc += 4;
		}
		pSrc += XSize*3;
	}
}

// This was hacked up pretty quick & slopily
// decompresses to 32 bit format 0xARGB
void ImageDXTC::DecompressDXT1(unsigned int * m_pDecompBytes, unsigned short * m_pCompBytes, int imageWidth, int imageHeight)
{
	unsigned int *		pBase  = (unsigned int *) m_pDecompBytes;
	unsigned int *		pImPos = (unsigned int *) pBase;			// pos in decompressed data
	//unsigned short *	pPos   = (unsigned short *) m_pCompBytes;	// pos in compressed data
	int					xblocks, yblocks;
	int					i,j;
	DXTColBlock *		pBlock;
	DXTColor8888			col_0, col_1, col_2, col_3;
	unsigned short		wrd;

	xblocks = imageWidth / 4;
	yblocks = imageHeight / 4;

	for( j=0; j < yblocks; j++ )
	{
		// 8 bytes per block
		pBlock = (DXTColBlock*) ( (unsigned int)m_pCompBytes + j * xblocks * 8 );

		for( i=0; i < xblocks; i++, pBlock++ )
		{
			// inline func:
			GetColorBlockColors( pBlock, &col_0, &col_1, &col_2, &col_3, wrd );

			// now decode the color block into the bitmap bits
			// inline func:
			pImPos = (unsigned int *)((unsigned int)pBase + i*16 + (j*4) * imageWidth * 4 );
			DecodeColorBlock(pImPos, pBlock, imageWidth, (unsigned int *)&col_0, (unsigned int *)&col_1, (unsigned int *)&col_2, (unsigned int *)&col_3);

		}
	}
}

// ----------------------------------------------------------------------------
// Block emission routines follow - These routines take a block of input colors,
// map them to the desired output colors, and emit the right bit patterns
// ----------------------------------------------------------------------------

void ImageDXTC::Emit1ColorBlock(unsigned short *pDest, DXT1Color c)
{
	pDest[0] = Make565(c);
	pDest[1] = 0;
	pDest[2] = 0;
	pDest[3] = 0;
}

void ImageDXTC::Emit2ColorBlock(unsigned short *pDest, DXT1Color c1, DXT1Color c2, DXT1Color *pSrc)
{
int x, y, Shift;
unsigned short Index;

	pDest[0] = Make565(c1);
	pDest[1] = Make565(c2);
	pDest[2] = 0;
	pDest[3] = 0;
	pDest += 2;

	unsigned char *pcDest = (unsigned char *)pDest;
	for(y=0; y<4; y++)
	{
		Shift = 0;
		for(x=0; x<4; x++)
		{
			if((pSrc[x].Col & Mask0565) == c1.Col)
				Index = 0;
			else
				Index = 1;

			*pcDest |= Index << Shift;
			Shift += 2;
		}
		pSrc += XSize;
		pcDest ++;
	}
}

void ImageDXTC::EmitMultiColorBlock4(unsigned short *pDest, CodeBook &cb, DXT1Color *pSrc)
{
int x, y, Shift;
unsigned short Index, Col1, Col2;
DXT1Color C, C2;

	C = *((DXT1Color *)&cb[0]);
	C2 = *((DXT1Color *)&cb[3]);

	Col1 = Make565(C);
	Col2 = Make565(C2);

	if(Col1 > Col2)
	{
		pDest[0] = Col1;
		pDest[1] = Col2;
	}
	else if(Col1 < Col2)
	{
		*((DXT1Color *)&cb[0]) = C2;
		*((DXT1Color *)&cb[3]) = C;
		C = *((DXT1Color *)&cb[1]);		// Shuffle the color table order around
		C2 = *((DXT1Color *)&cb[2]);
		*((DXT1Color *)&cb[1]) = C2;
		*((DXT1Color *)&cb[2]) = C;

		pDest[0] = Col2;
		pDest[1] = Col1;
	}
	else
	{
		// Both colors are equal - Emit the block and return
		pDest[0] = Col1;
		pDest[1] = 0;
		pDest[2] = pDest[3] = 0;
		return;
	}

	pDest[2] = 0;
	pDest[3] = 0;
	pDest += 2;

	unsigned char *pcDest = (unsigned char *)pDest;
	for(y=0; y<4; y++)
	{
		Shift = 0;
		for(x=0; x<4; x++)
		{
			Index = ColorBits4[ cb.FindVectorSlow( *((cbVector *)(pSrc+x)) ) ];
			*pcDest |= Index << Shift;
			Shift += 2;
		}
		pSrc += XSize;
		pcDest ++;
	}
}

void ImageDXTC::EmitMultiColorBlock3(unsigned short *pDest, CodeBook &cb, DXT1Color *pSrc)
{
int x, y, Shift;
unsigned short Index, Col1, Col2;
DXT1Color C, C2;

	C = *((DXT1Color *)&cb[0]);
	C2 = *((DXT1Color *)&cb[2]);

	Col1 = Make565(C);
	Col2 = Make565(C2);

	if(Col1 > Col2)
	{
		*((DXT1Color *)&cb[0]) = C2;
		*((DXT1Color *)&cb[2]) = C;		// Shuffle the color table order around
		pDest[0] = Col2;
		pDest[1] = Col1;
	}
	else
	{
		pDest[0] = Col1;
		pDest[1] = Col2;
	}

	pDest[2] = 0;
	pDest[3] = 0;
	pDest += 2;

	unsigned char *pcDest = (unsigned char *)pDest;
	for(y=0; y<4; y++)
	{
		Shift = 0;
		for(x=0; x<4; x++)
		{
			C = pSrc[x];
			C.a = 0;
			Index = ColorBits3[ cb.FindVectorSlow( *((cbVector *)(&C)) ) ];

			*pcDest |= Index << Shift;
			Shift += 2;
		}
		pSrc += XSize;
		pcDest ++;
	}
}

void ImageDXTC::GetColorBlockColors(DXTColBlock * pBlock, DXTColor8888 * col_0, DXTColor8888 * col_1, DXTColor8888 * col_2, DXTColor8888 * col_3, unsigned short & wrd)
{ 
	/*
	DXTColor565 * pCol;

	pCol = (DXTColor565*) &(pBlock->col0);
	col_0->a = 0xff;
	col_0->r = pCol->nRed;
	col_0->r <<= 3;				// shift to full precision
	col_0->g = pCol->nGreen;
	col_0->g <<= 2;
	col_0->b = pCol->nBlue;
	col_0->b <<= 3;

	pCol = (DXTColor565*) &(pBlock->col1);
	col_1->a = 0xff;
	col_1->r = pCol->nRed;
	col_1->r <<= 3;				// shift to full precision
	col_1->g = pCol->nGreen;
	col_1->g <<= 2;
	col_1->b = pCol->nBlue;
	col_1->b <<= 3;
	*/

	*col_0 = pBlock->col0;
	col_0->r <<= 3;
	col_0->g <<= 2;
	col_0->b <<= 3;
	col_0->a = 0x80;

	*col_1 = pBlock->col1;
	col_1->r <<= 3;
	col_1->g <<= 2;
	col_1->b <<= 3;
	col_1->a = 0x80;
	if( pBlock->col0 > pBlock->col1 )
	{
		// Four-color block: derive the other two colors.    
		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
		// These two bit codes correspond to the 2-bit fields 
		// stored in the 64-bit block.
		wrd = ((unsigned short)col_0->r * 2 + (unsigned short)col_1->r )/3;
											// no +1 for rounding
											// as bits have been shifted to 888
		col_2->r = (unsigned char)wrd;

		wrd = ((unsigned short)col_0->g * 2 + (unsigned short)col_1->g )/3;
		col_2->g = (unsigned char)wrd;

		wrd = ((unsigned short)col_0->b * 2 + (unsigned short)col_1->b )/3;
		col_2->b = (unsigned char)wrd;
		col_2->a = 0x80;

		wrd = ((unsigned short)col_0->r + (unsigned short)col_1->r *2 )/3;
		col_3->r = (unsigned char)wrd;

		wrd = ((unsigned short)col_0->g + (unsigned short)col_1->g *2 )/3;
		col_3->g = (unsigned char)wrd;

		wrd = ((unsigned short)col_0->b + (unsigned short)col_1->b *2 )/3;
		col_3->b = (unsigned char)wrd;
		col_3->a = 0x80;

	}
	else
	{
		// Three-color block: derive the other color.
		// 00 = color_0,  01 = color_1,  10 = color_2,  
		// 11 = transparent.
		// These two bit codes correspond to the 2-bit fields 
		// stored in the 64-bit block. 

		// explicit for each component, unlike some refrasts...
		
		// TRACE("block has alpha\n");

		wrd = ((unsigned short)col_0->r + (unsigned short)col_1->r )/2;
		col_2->r = (unsigned char)wrd;
		wrd = ((unsigned short)col_0->g + (unsigned short)col_1->g )/2;
		col_2->g = (unsigned char)wrd;
		wrd = ((unsigned short)col_0->b + (unsigned short)col_1->b )/2;
		col_2->b = (unsigned char)wrd;
		col_2->a = 0x80;

		col_3->r = 0x00;		// random color to indicate alpha
		col_3->g = 0xff;
		col_3->b = 0xff;
		col_3->a = 0x00;

	}
}

void ImageDXTC::DecodeColorBlock(unsigned int * pImPos, DXTColBlock * pColorBlock, int width, unsigned int * col_0, unsigned int * col_1, unsigned int * col_2, unsigned int * col_3 )
{
	// width is width of image in pixels


	unsigned int bits;
	int r,n;

	// bit masks = 00000011, 00001100, 00110000, 11000000
	const unsigned int masks[] = { 3, 12, 3 << 4, 3 << 6 };
	const int   shift[] = { 0, 2, 4, 6 };

	// r steps through lines in y
	for( r=0; r < 4; r++, pImPos += width-4 )	// no width*4 as unsigned int ptr inc will *4
	{

		// width * 4 bytes per pixel per line
		// each j dxtc row is 4 lines of pixels

		// pImPos = (unsigned int*)((unsigned int)pBase + i*16 + (r+j*4) * m_nWidth * 4 );

		// n steps through pixels
		for( n=0; n < 4; n++ )
		{
			bits =		pColorBlock->row[r] & masks[n];
			bits >>=	shift[n];

			switch( bits )
			{
			case 0 :
				*pImPos = *col_0;
				pImPos++;		// increment to next unsigned int
				break;
			case 1 :
				*pImPos = *col_1;
				pImPos++;
				break;
			case 2 :
				*pImPos = *col_2;
				pImPos++;
				break;
			case 3 :
				*pImPos = *col_3;
				pImPos++;
				break;
			default:
				//assert(0);
				//TRACE("Your logic is jacked! bits == 0x%x\n", bits );
				//pImPos++;
				break;
			}
		}
	}
}
